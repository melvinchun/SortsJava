/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package proyecto_ordenamiento;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Random;

/**
 *
 * @author alvarez
 */
public class Proyecto extends javax.swing.JFrame {

    /**
     * Creates new form Proyecto
     */
    public Proyecto() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        input = new javax.swing.JComboBox<>();
        sort = new javax.swing.JComboBox<>();
        run = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jButton1 = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jPanel1.setBackground(new java.awt.Color(255, 255, 255));
        jPanel1.setForeground(new java.awt.Color(255, 255, 255));

        input.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "10", "100", "1000", "10000", "100000", "1000000" }));

        sort.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "Bubble Sort", "Insert Sort", "Selection Sort", "Merge Sort", "Heap Sort", "Quick Sort" }));

        run.setText("Run");
        run.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                runActionPerformed(evt);
            }
        });

        jLabel1.setText("Sort");

        jLabel2.setText("Input");

        jButton1.setText("Auto");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jButton1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(run)
                .addContainerGap())
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGap(30, 30, 30)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel2)
                    .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                        .addComponent(input, 0, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(sort, javax.swing.GroupLayout.PREFERRED_SIZE, 150, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addComponent(jLabel1))
                .addContainerGap(166, Short.MAX_VALUE))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap(24, Short.MAX_VALUE)
                .addComponent(jLabel2)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(input, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(17, 17, 17)
                .addComponent(jLabel1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(sort, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(run)
                    .addComponent(jButton1))
                .addGap(7, 7, 7))
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void runActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_runActionPerformed
        long startTime = System.nanoTime();
        int n = Integer.parseInt(this.input.getSelectedItem().toString());
        int[] array = createArray(n);
        if (this.sort.getSelectedItem().toString().equals("Bubble Sort")) {
            System.out.println("Metodo: Bubble Sort");
            System.out.println("Input: " + n);
            bubbleSort(array);
        } else if (this.sort.getSelectedItem().toString().equals("Insert Sort")) {
            System.out.println("Metodo: Insert Sort");
            System.out.println("Input: " + n);
            insertionSort(array);
        } else if (this.sort.getSelectedItem().toString().equals("Selection Sort")) {
            System.out.println("Metodo: Selection Sort");
            System.out.println("Input: " + n);
            selectionSort(array);
        } else if (this.sort.getSelectedItem().toString().equals("Merge Sort")) {
            System.out.println("Metodo: Merge Sort");
            System.out.println("Input: " + n);
            mergeSort(array);
        } else if (this.sort.getSelectedItem().toString().equals("Heap Sort")) {
            System.out.println("Metodo: Heap Sort");
            System.out.println("Input: " + n);
            heapSort(array);
        } else if (this.sort.getSelectedItem().toString().equals("Quick Sort")) {

        }
        long endTime = System.nanoTime();
        long totalTime = endTime - startTime;
        System.out.println("Time: " + totalTime + "ns\n");
    }//GEN-LAST:event_runActionPerformed

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        BufferedWriter writer = null;
        try {
            File logFile = new File("Log2");
            System.out.println(logFile.getCanonicalPath());
            writer = new BufferedWriter(new FileWriter(logFile));

            int n = 10;
            while(n <= 1000000){

                //Heap Sort
                for (int i = 0; i < 10; i++) {
                    long startTime = System.nanoTime();
                    int[] array = createArray(n);
                    System.out.println("Metodo: Heap Sort");
                    writer.write("Metodo: Heap Sort\n");
                    System.out.println("Input: " + n);
                    writer.write("Input: " + n + "\n");
                    heapSort(array);
                    long endTime = System.nanoTime();
                    long totalTime = endTime - startTime;
                    System.out.println("Time: " + totalTime + "ns\n");
                    writer.write("Time: " + totalTime + "ns\n");
                }
                
                //Bubble Sort
                for (int i = 0; i < 10; i++) {
                    long startTime = System.nanoTime();
                    int[] array = createArray(n);
                    System.out.println("Metodo: Bubble Sort");
                    writer.write("Metodo: Bubble Sort\n");
                    System.out.println("Input: " + n);
                    writer.write("Input: " + n + "\n");
                    bubbleSort(array);
                    long endTime = System.nanoTime();
                    long totalTime = endTime - startTime;
                    System.out.println("Time: " + totalTime + "ns\n");
                    writer.write("Time: " + totalTime + "ns\n");
                }
                //Insert
                for (int i = 0; i < 10; i++) {
                    long startTime = System.nanoTime();
                    int[] array = createArray(n);
                    System.out.println("Metodo: Insert Sort");
                    writer.write("Metodo: Insert Sort\n");
                    System.out.println("Input: " + n);
                    writer.write("Input: " + n + "\n");
                    insertionSort(array);
                    long endTime = System.nanoTime();
                    long totalTime = endTime - startTime;
                    System.out.println("Time: " + totalTime + "ns\n");
                    writer.write("Time: " + totalTime + "ns\n");
                }
                //Select Sort
                for (int i = 0; i < 10; i++) {
                    long startTime = System.nanoTime();
                    int[] array = createArray(n);
                    System.out.println("Metodo: Selection Sort");
                    writer.write("Metodo: Selection Sort\n");
                    System.out.println("Input: " + n);
                    writer.write("Input: " + n + "\n");
                    selectionSort(array);
                    long endTime = System.nanoTime();
                    long totalTime = endTime - startTime;
                    System.out.println("Time: " + totalTime + "ns\n");
                    writer.write("Time: " + totalTime + "ns\n");
                }

                //Merge Sort
                for (int i = 0; i < 10; i++) {
                    long startTime = System.nanoTime();
                    int[] array = createArray(n);
                    System.out.println("Metodo: Merge Sort");
                    writer.write("Metodo: Merge Sort\n");
                    System.out.println("Input: " + n);
                    writer.write("Input: " + n + "\n");
                    mergeSort(array);
                    long endTime = System.nanoTime();
                    long totalTime = endTime - startTime;
                    System.out.println("Time: " + totalTime + "ns\n");
                    writer.write("Time: " + totalTime + "ns\n");
                }
                //Quick Sort
                for (int i = 0; i < 10; i++) {
                    long startTime = System.nanoTime();
                    int[] array = createArray(n);
                    System.out.println("Metodo: Quick Sort");
                    writer.write("Metodo: Quick Sort\n");
                    System.out.println("Input: " + n);
                    writer.write("Input: " + n + "\n");
                    int low = 0;
                    int high = array.length - 1;
                    quickSort(array, low, high);
                    long endTime = System.nanoTime();
                    long totalTime = endTime - startTime;
                    System.out.println("Time: " + totalTime + "ns\n");
                    writer.write("Time: " + totalTime + "ns\n");
                }
                
               
                n=n*10;		
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            try {
                // Close the writer regardless of what happens...
                writer.close();
            } catch (Exception e) {
            }
        }


    }//GEN-LAST:event_jButton1ActionPerformed

    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Proyecto.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Proyecto.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Proyecto.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Proyecto.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Proyecto().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JComboBox<String> input;
    private javax.swing.JButton jButton1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JButton run;
    private javax.swing.JComboBox<String> sort;
    // End of variables declaration//GEN-END:variables
    private static int total;
    public static int[] createArray(int n){
         Random rand = new Random();
         int[] array= new int[n];
         for (int i = 0; i < n; i++) {
            array[i]=rand.nextInt(1000)+1;
        }
         return array;
    }

    public static void bubbleSort(int[] numArray) {
        int n = numArray.length;
        int temp = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 1; j < (n - i); j++) {
                if (numArray[j - 1] > numArray[j]) {
                    temp = numArray[j - 1];
                    numArray[j - 1] = numArray[j];
                    numArray[j] = temp;
                }
            }
        }
    }

    void insertionSort(int[] arr) {
        int i, j, newValue;
        for (i = 1; i < arr.length; i++) {
            newValue = arr[i];
            j = i;
            while (j > 0 && arr[j - 1] > newValue) {
                arr[j] = arr[j - 1];
                j--;
            }
            arr[j] = newValue;
        }
    }

    public void selectionSort(int[] arr) {
        int i, j, minIndex, tmp;
        int n = arr.length;
        for (i = 0; i < n - 1; i++) {
            minIndex = i;
            for (j = i + 1; j < n; j++) {
                if (arr[j] < arr[minIndex]) {
                    minIndex = j;
                }
            }
            if (minIndex != i) {
                tmp = arr[i];
                arr[i] = arr[minIndex];
                arr[minIndex] = tmp;
            }
        }
    }

    static void mergeSort(int[] A) {
        if (A.length > 1) {
            int q = A.length / 2;

            int[] leftArray = Arrays.copyOfRange(A, 0, q);
            int[] rightArray = Arrays.copyOfRange(A, q, A.length);

            mergeSort(leftArray);
            mergeSort(rightArray);

            merge(A, leftArray, rightArray);
        }
    }

    static void merge(int[] a, int[] l, int[] r) {
        int totElem = l.length + r.length;
        //int[] a = new int[totElem];
        int i, li, ri;
        i = li = ri = 0;
        while (i < totElem) {
            if ((li < l.length) && (ri < r.length)) {
                if (l[li] < r[ri]) {
                    a[i] = l[li];
                    i++;
                    li++;
                } else {
                    a[i] = r[ri];
                    i++;
                    ri++;
                }
            } else {
                if (li >= l.length) {
                    while (ri < r.length) {
                        a[i] = r[ri];
                        i++;
                        ri++;
                    }
                }
                if (ri >= r.length) {
                    while (li < l.length) {
                        a[i] = l[li];
                        li++;
                        i++;
                    }
                }
            }
        }
    }

    private static int[] a;
    private static int n;
    private static int left;
    private static int right;
    private static int largest;

    public static void buildheap(int[] a) {
        n = a.length - 1;
        for (int i = n / 2; i >= 0; i--) {
            maxheap(a, i);
        }
    }

    public static void maxheap(int[] a, int i) {
        left = 2 * i;
        right = 2 * i + 1;
        if (left <= n && a[left] > a[i]) {
            largest = left;
        } else {
            largest = i;
        }

        if (right <= n && a[right] > a[largest]) {
            largest = right;
        }
        if (largest != i) {
            exchange(i, largest);
            maxheap(a, largest);
        }
    }

    public static void exchange(int i, int j) {
        int t = a[i];
        a[i] = a[j];
        a[j] = t;
    }

    public static void heapSort(int[] a0) {
        a = a0;
        buildheap(a);

        for (int i = n; i > 0; i--) {
            exchange(0, i);
            n = n - 1;
            maxheap(a, 0);
        }
    }

    public static void quickSort(int[] arr, int low, int high) {
        if (arr == null || arr.length == 0) {
            return;
        }

        if (low >= high) {
            return;
        }

        // pick the pivot
        int middle = low + (high - low) / 2;
        int pivot = arr[middle];

        // make left < pivot and right > pivot
        int i = low, j = high;
        while (i <= j) {
            while (arr[i] < pivot) {
                i++;
            }

            while (arr[j] > pivot) {
                j--;
            }

            if (i <= j) {
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
                i++;
                j--;
            }
        }

        // recursively sort two sub parts
        if (low < j) {
            quickSort(arr, low, j);
        }

        if (high > i) {
            quickSort(arr, i, high);
        }
    }
}
